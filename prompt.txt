<documents>
<document index="1">
<source>src/index.ts</source>
<document_content>
import { initializeBot } from './bot';
import express from 'express';
import { db } from './db';
import { messages, summaries, groupConfigs } from './db/schema';
import { count } from 'drizzle-orm';

const app = express();
const PORT = process.env.METRICS_PORT || 9090;

async function setupMetricsEndpoint() {
  app.get('/metrics', async (req, res) => {
    const [messageCount] = await db.select({ value: count() }).from(messages);
    const [summaryCount] = await db.select({ value: count() }).from(summaries);
    const [groupCount] = await db.select({ value: count() }).from(groupConfigs);
    
    res.json({
      total_messages: messageCount.value,
      total_summaries: summaryCount.value,
      active_groups: groupCount.value,
      uptime: process.uptime(),
      memory_usage: process.memoryUsage(),
    });
  });

  app.listen(PORT, () => {
    console.log(`Metrics endpoint listening on port ${PORT}`);
  });
}

async function main() {
  try {
    await initializeBot();
    await setupMetricsEndpoint();
    console.log('Application started successfully');
  } catch (error) {
    console.error('Failed to start application:', error);
    process.exit(1);
  }
}

main(); 

</document_content>
</document>
<document index="2">
<source>src/types/message.ts</source>
<document_content>
export interface Message {
  messageId: number;
  chatId: number;
  userId: number;
  username?: string;
  content: string;
  timestamp: number;
  threadId?: number;
  replyToMessageId?: number;
  references?: MessageReference[];
}

export interface MessageReference {
  type: 'reply' | 'mention' | 'edit' | 'summary';
  targetMessageId: number;
  resolvedUsername?: string;
}

export const ReferenceType = {
  REPLY: 'reply',
  MENTION: 'mention',
  EDIT: 'edit',
  SUMMARY: 'summary',
} as const;

</document_content>
</document>
<document index="3">
<source>src/llm/client.ts</source>
<document_content>
import Instructor from '@instructor-ai/instructor';
import OpenAI from 'openai';
import { z } from 'zod';

// Initialize OpenAI client
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

// Initialize Instructor client
export const instructor = Instructor({
  client: openai,
  mode: 'TOOLS',
});

// Define summary schema using Zod
export const SummarySchema = z.object({
  title: z.string().describe('A brief title for the summary'),
  sections: z.array(z.object({
    title: z.string().describe('Section title'),
    content: z.string().describe('Section content'),
    topicCluster: z.string().optional().describe('Associated topic cluster')
  })).describe('Organized sections of the summary'),
  mainTopics: z.array(z.object({
    name: z.string().describe('Topic name'),
    relevance: z.number().min(0).max(1).describe('Topic relevance score')
  })).describe('Main topics discussed in the conversation'),
  summary: z.string().describe('A concise summary of the conversation'),
  keyParticipants: z.array(z.string()).describe('Key participants in the conversation'),
  actionItems: z.array(z.string()).optional().describe('Any action items or decisions made'),
  sentiment: z.enum(['positive', 'neutral', 'negative']).describe('Overall sentiment of the conversation'),
});

export type Summary = z.infer<typeof SummarySchema>;

// Rate limiting configuration
export const RATE_LIMIT = {
  maxTokensPerMinute: 90000, // OpenAI's default rate limit for GPT-3.5
  maxRequestsPerMinute: 3500,
};

// Error handling wrapper
export async function withErrorHandling<T>(
  operation: () => Promise<T>,
  retries = 3,
  delayMs = 1000
): Promise<T> {
  let lastError: Error | null = null;

  for (let attempt = 0; attempt < retries; attempt++) {
    try {
      return await operation();
    } catch (error) {
      lastError = error as Error;
      
      if (error instanceof OpenAI.APIError) {
        // Handle rate limiting
        if (error.status === 429) {
          await new Promise(resolve => setTimeout(resolve, delayMs * (attempt + 1)));
          continue;
        }
      }
      
      // Log the error but continue retrying
      console.error(`OpenAI API error (attempt ${attempt + 1}/${retries}):`, error);
    }
  }

  throw lastError || new Error('Operation failed after multiple retries');
} 

</document_content>
</document>
<document index="4">
<source>src/llm/clustering.ts</source>
<document_content>
import { instructor } from './client';
import { z } from 'zod';

// Define the topic cluster schema
export const TopicClusterSchema = z.object({
  topics: z.array(z.object({
    name: z.string().describe('Name of the topic cluster'),
    keywords: z.array(z.string()).describe('Key terms associated with this topic'),
    messageIds: z.array(z.number()).describe('IDs of messages in this topic cluster'),
    confidence: z.number().min(0).max(1).describe('Confidence score for this clustering')
  })),
  unclustered: z.array(z.number()).describe('Message IDs that could not be clustered')
});

export type TopicCluster = z.infer<typeof TopicClusterSchema>;

export async function clusterMessages(messages: Array<{ id: number, content: string }>) {
  const prompt = `Analyze these messages and group them into coherent topics. 
    Consider semantic similarity, shared keywords, and conversation flow.
    Messages that don't fit clearly into any topic should be marked as unclustered.
    Ensure each topic has a descriptive name and relevant keywords.`;

  try {
    const response = await instructor.chat<z.infer<typeof TopicClusterSchema>>({
      messages: [
        {
          role: 'system',
          content: prompt
        },
        {
          role: 'user',
          content: JSON.stringify(messages.map(m => m.content))
        }
      ],
      schema: TopicClusterSchema
    });

    return response;
  } catch (error) {
    console.error('Error in topic clustering:', error);
    throw error;
  }
}

</document_content>
</document>
<document index="5">
<source>src/llm/scheduler.ts</source>
<document_content>
import { db } from '../db';
import { groupConfigs } from '../db/schema';
import { eq } from 'drizzle-orm';
import { batchMessages, generateSummary, storeSummary } from './summarizer';
import { bot } from '../bot';
import { Summary } from './client';

export async function initializeSummaryScheduler() {
  // Check for summaries every minute
  setInterval(checkAndGenerateSummaries, 60 * 1000);
}

async function checkAndGenerateSummaries() {
  try {
    // Get all active group configurations
    const configs = await db.query.groupConfigs.findMany({
      where: eq(groupConfigs.isActive, true),
    });

    // Process each active group
    for (const config of configs) {
      await processGroupSummary(config, true);
    }
  } catch (error) {
    console.error('Error in summary scheduler:', error);
  }
}

function formatSummary(summary: Summary): string {
  const sentiment = {
    positive: 'ðŸ˜Š',
    neutral: 'ðŸ˜',
    negative: 'ðŸ˜•',
  };

  return `ðŸ“‹ *Conversation Summary*\n\n` +
    `*Main Topics:*\n${summary.mainTopics.map(topic => `â€¢ ${topic}`).join('\n')}\n\n` +
    `*Summary:*\n${summary.summary}\n\n` +
    `*Key Participants:*\n${summary.keyParticipants.map(participant => `â€¢ ${participant}`).join('\n')}\n\n` +
    (summary.actionItems && summary.actionItems.length > 0 
      ? `*Action Items:*\n${summary.actionItems.map(item => `â€¢ ${item}`).join('\n')}\n\n`
      : '') +
    `*Overall Sentiment:* ${sentiment[summary.sentiment]}`;
}

async function processGroupSummary(config: any, autoSend: boolean = false) {
  try {
    // Get messages batch for the group
    const batch = await batchMessages(config.chatId, config.summaryInterval / 60);
    
    if (!batch) {
      return null; // Not enough messages for summary
    }

    // Generate summary
    const summary = await generateSummary(batch);
    await storeSummary(config.chatId, summary);

    // Format summary
    const formattedSummary = formatSummary(summary);

    // If autoSend is true (scheduler) or it's a manual trigger without a return handler
    if (autoSend) {
      await bot.api.sendMessage(config.chatId, formattedSummary, {
        parse_mode: 'Markdown',
      });
    }

    return formattedSummary;
  } catch (error) {
    console.error(`Error processing summary for chat ${config.chatId}:`, error);
    return null;
  }
}

// Export for manual trigger support
export async function triggerManualSummary(chatId: number): Promise<string | null> {
  const config = await db.query.groupConfigs.findFirst({
    where: eq(groupConfigs.chatId, chatId),
  });

  if (!config) {
    throw new Error('Group configuration not found');
  }

  return await processGroupSummary(config, false);
}

</document_content>
</document>
<document index="6">
<source>src/llm/summarizer.ts</source>
<document_content>
import { instructor, SummarySchema, withErrorHandling } from './client';
import { messages as messagesTable, summaries } from '../db/schema';
import { z } from 'zod';

const TOPIC_KEYWORDS = {
  tech: ['ai', 'code', 'server', 'database', 'api', 'framework'],
  support: ['help', 'issue', 'error', 'bug', 'fix', 'problem'],
  offTopic: ['meme', 'joke', 'offtopic', 'random', 'funny']
};
import type { InferSelectModel } from 'drizzle-orm';
import { eq } from 'drizzle-orm';
import { db } from '../db';

// Configuration
const MAX_MESSAGES_PER_BATCH = 50;
const MIN_MESSAGES_FOR_SUMMARY = 5;
const MAX_TOKENS_PER_REQUEST = 4000;

type Message = InferSelectModel<typeof messagesTable>;

interface MessageBatch {
  messages: Message[];
  chatId: number;
  startTime: Date;
  endTime: Date;
}

export async function batchMessages(chatId: number, timeWindowMinutes: number = 360): Promise<MessageBatch | null> {
  const cutoffTime = new Date(Date.now() - timeWindowMinutes * 60 * 1000);
  
  const batchMessages = await db.query.messages.findMany({
    where: eq(messagesTable.chatId, chatId),
    orderBy: (messages, { asc }) => [asc(messages.createdAt)],
    limit: MAX_MESSAGES_PER_BATCH,
  });

  if (batchMessages.length < MIN_MESSAGES_FOR_SUMMARY) {
    return null;
  }

  return {
    messages: batchMessages,
    chatId,
    startTime: new Date(batchMessages[0].createdAt),
    endTime: new Date(batchMessages[batchMessages.length - 1].createdAt),
  };
}

function detectTopics(messages: Message[]): string[] {
  const content = messages.map(m => m.content).join(' ').toLowerCase();
  return Object.entries(TOPIC_KEYWORDS)
    .filter(([_, keywords]) => keywords.some(kw => content.includes(kw)))
    .map(([topic]) => topic);
}

export async function generateSummary(batch: MessageBatch) {
  const messageText = batch.messages
    .map(msg => `${msg.username || 'Unknown'}: ${msg.content}`)
    .join('\n');
  
  const detectedTopics = detectTopics(batch.messages);

  return await withErrorHandling(async () => {
    const summary = await instructor.chat.completions.create({
      messages: [
        {
          role: 'system',
          content: 'You are a helpful assistant that summarizes group chat conversations. Focus on key points, decisions, and action items.',
        },
        {
          role: 'user',
          content: `Please analyze and summarize the following conversation:\n\n${messageText}`,
        },
      ],
      model: 'gpt-3.5-turbo',
      response_model: {
        schema: SummarySchema.extend({
          topics: z.array(z.string()).optional()
        }),
        name: 'EnhancedSummary',
      },
      temperature: 0.7,
      max_tokens: MAX_TOKENS_PER_REQUEST,
    });

    return summary;
  });
}

export async function storeSummary(chatId: number, summary: any, batch: MessageBatch) {
  const [created] = await db.insert(summaries).values({
    chatId,
    content: summary.content,
    messageCount: batch.messages.length,
    startTimestamp: batch.startTime,
    endTimestamp: batch.endTime,
    tokensUsed: summary.usage?.total_tokens,
    topics: JSON.stringify(summary.topics || []),
  }).returning();
  return created;
} 

</document_content>
</document>
<document index="7">
<source>src/db/index.ts</source>
<document_content>
import { drizzle } from 'drizzle-orm/bun-sqlite';
import { Database } from 'bun:sqlite';
import { config } from 'dotenv';
import * as schema from './schema';
import { mkdir } from 'node:fs/promises';
import { dirname, resolve } from 'node:path';

config();

if (!process.env.DATABASE_URL) {
  throw new Error('DATABASE_URL environment variable is required');
}

// Extract the file path from the URL and resolve it relative to project root
const dbPath = resolve(process.cwd(), process.env.DATABASE_URL.replace('sqlite:', ''));

// Ensure the directory exists
await mkdir(dirname(dbPath), { recursive: true });

// Initialize SQLite database
const sqlite = new Database(dbPath);

// Create drizzle database instance
export const db = drizzle(sqlite, { schema });

// Export schema for use in other parts of the application
export { schema }; 
</document_content>
</document>
<document index="8">
<source>src/db/init.ts</source>
<document_content>
import { runMigrations } from './migrate';
import { db } from './index';

export async function initializeDatabase() {
  try {
    console.log('Initializing database...');
    
    // Run migrations
    await runMigrations();
    
    // Test database connection by checking if migrations table exists
    await db.run('SELECT 1');
    console.log('Database connection successful');
    console.log('Database initialization completed');
  } catch (error) {
    console.error('Failed to initialize database:', error);
    throw error;
  }
} 
</document_content>
</document>
<document index="9">
<source>src/db/migrate.ts</source>
<document_content>
import { migrate } from 'drizzle-orm/bun-sqlite/migrator';
import { db } from './index';

// Run migrations
export async function runMigrations() {
  try {
    console.log('Running database migrations...');
    await migrate(db, { migrationsFolder: './src/db/migrations' });
    console.log('Database migrations completed successfully');
  } catch (error) {
    console.error('Error running database migrations:', error);
    throw error;
  }
} 
</document_content>
</document>
<document index="10">
<source>src/db/schema.ts</source>
<document_content>
import { sqliteTable, text, integer } from 'drizzle-orm/sqlite-core';
import { sql } from 'drizzle-orm';

// Messages table to store all chat messages
export const messages = sqliteTable('messages', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  messageId: integer('message_id').notNull(),
  chatId: integer('chat_id').notNull(),
  userId: integer('user_id').notNull(),
  username: text('username'),
  content: text('content').notNull(),
  timestamp: integer('timestamp', { mode: 'number' }).notNull(),
  threadId: integer('thread_id'),
  replyToMessageId: integer('reply_to_message_id'),
  sentiment_score: integer('sentiment_score'),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull().default(sql`CURRENT_TIMESTAMP`),
  embedding: text('embedding'), // Store text-embedding-3-small vectors
});

// Group configurations table
export const groupConfigs = sqliteTable('group_configs', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  chatId: integer('chat_id').unique().notNull(),
  summaryInterval: integer('summary_interval').notNull().default(21600), // 6 hours in seconds
  minMessagesForSummary: integer('min_messages_for_summary').notNull().default(10),
  isActive: integer('is_active', { mode: 'boolean' }).notNull().default(true),
  summaryFormat: text('summary_format').notNull().default('markdown'),
  language: text('language').notNull().default('en'),
  schemaVersion: integer('schema_version').notNull().default(1),
  maxDailyTokens: integer('max_daily_tokens'),
  maxSummaryTokens: integer('max_summary_tokens'),
  tokenUsageAlert: integer('token_usage_alert_percent'),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull().default(sql`CURRENT_TIMESTAMP`),
  updatedAt: integer('updated_at', { mode: 'timestamp' }).notNull().default(sql`CURRENT_TIMESTAMP`),
});

// Summaries table
export const summaries = sqliteTable('summaries', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  chatId: integer('chat_id').notNull(),
  content: text('content').notNull(),
  messageCount: integer('message_count').notNull(),
  startTimestamp: integer('start_timestamp', { mode: 'timestamp' }).notNull(),
  endTimestamp: integer('end_timestamp', { mode: 'timestamp' }).notNull(),
  tokensUsed: integer('tokens_used'),
  format: text('format').notNull().default('markdown'),
  alertSent: integer('alert_sent', { mode: 'boolean' }).default(false),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull().default(sql`CURRENT_TIMESTAMP`),
});

export const messageReferences = sqliteTable('message_references', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  sourceMessageId: integer('source_message_id').notNull(),
  targetMessageId: integer('target_message_id').notNull(),
  referenceType: text('reference_type').notNull(),
  resolvedUsername: text('resolved_username'),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull().default(sql`CURRENT_TIMESTAMP`),
});

export const summaryFeedback = sqliteTable('summary_feedback', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  summaryId: integer('summary_id').references(() => summaries.id),
  chatId: integer('chat_id').notNull(),
  userId: integer('user_id').notNull(),
  rating: integer('rating').notNull(),
  feedbackText: text('feedback_text'),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull().default(sql`CURRENT_TIMESTAMP`),
});

export const userEngagement = sqliteTable('user_engagement', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  userId: integer('user_id').notNull(),
  chatId: integer('chat_id').notNull(),
  messageCount: integer('message_count').notNull().default(0),
  commandCount: integer('command_count').notNull().default(0),
  replyCount: integer('reply_count').notNull().default(0),
  mentionCount: integer('mention_count').notNull().default(0),
  lastActive: integer('last_active', { mode: 'timestamp' }).notNull(),
  dailyActiveStreak: integer('daily_active_streak').notNull().default(0),
  averageResponseTime: integer('average_response_time'),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull().default(sql`CURRENT_TIMESTAMP`),
  updatedAt: integer('updated_at', { mode: 'timestamp' }).notNull().default(sql`CURRENT_TIMESTAMP`),
});

</document_content>
</document>
<document index="11">
<source>src/db/migrations/0000_first_golden_guardian.sql</source>
<document_content>
CREATE TABLE `group_configs` (
	`id` integer PRIMARY KEY AUTOINCREMENT NOT NULL,
	`chat_id` integer NOT NULL,
	`summary_interval` integer DEFAULT 21600 NOT NULL,
	`min_messages_for_summary` integer DEFAULT 10 NOT NULL,
	`is_active` integer DEFAULT true NOT NULL,
	`created_at` integer DEFAULT CURRENT_TIMESTAMP NOT NULL,
	`updated_at` integer DEFAULT CURRENT_TIMESTAMP NOT NULL
);
--> statement-breakpoint
CREATE UNIQUE INDEX `group_configs_chat_id_unique` ON `group_configs` (`chat_id`);--> statement-breakpoint
CREATE TABLE `messages` (
	`id` integer PRIMARY KEY AUTOINCREMENT NOT NULL,
	`message_id` integer NOT NULL,
	`chat_id` integer NOT NULL,
	`user_id` integer NOT NULL,
	`username` text,
	`content` text NOT NULL,
	`timestamp` integer NOT NULL,
	`thread_id` integer,
	`reply_to_message_id` integer,
	`created_at` integer DEFAULT CURRENT_TIMESTAMP NOT NULL
);
--> statement-breakpoint
CREATE TABLE `summaries` (
	`id` integer PRIMARY KEY AUTOINCREMENT NOT NULL,
	`chat_id` integer NOT NULL,
	`content` text NOT NULL,
	`message_count` integer NOT NULL,
	`start_timestamp` integer NOT NULL,
	`end_timestamp` integer NOT NULL,
	`tokens_used` integer,
	`created_at` integer DEFAULT CURRENT_TIMESTAMP NOT NULL
);

</document_content>
</document>
<document index="12">
<source>src/db/migrations/0001_message_references.sql</source>
<document_content>
-- Create message_references table
CREATE TABLE IF NOT EXISTS message_references (
  id INTEGER PRIMARY KEY,
  source_message_id INTEGER NOT NULL,
  target_message_id INTEGER NOT NULL,
  reference_type TEXT NOT NULL,
  resolved_username TEXT,
  created_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now'))
);

-- Add sentiment_score column to messages if it doesn't exist
ALTER TABLE messages ADD COLUMN sentiment_score INTEGER;

-- Add alert_sent column to summaries if it doesn't exist
ALTER TABLE summaries ADD COLUMN alert_sent INTEGER DEFAULT 0;

</document_content>
</document>
<document index="13">
<source>src/db/migrations/0001_neat_katie_power.sql</source>
<document_content>
CREATE TABLE `message_references` (
	`id` integer PRIMARY KEY AUTOINCREMENT NOT NULL,
	`source_message_id` integer NOT NULL,
	`target_message_id` integer NOT NULL,
	`reference_type` text NOT NULL,
	`resolved_username` text,
	`created_at` integer DEFAULT CURRENT_TIMESTAMP NOT NULL
);
--> statement-breakpoint
CREATE TABLE `summary_feedback` (
	`id` integer PRIMARY KEY AUTOINCREMENT NOT NULL,
	`summary_id` integer,
	`chat_id` integer NOT NULL,
	`user_id` integer NOT NULL,
	`rating` integer NOT NULL,
	`feedback_text` text,
	`created_at` integer DEFAULT CURRENT_TIMESTAMP NOT NULL,
	FOREIGN KEY (`summary_id`) REFERENCES `summaries`(`id`) ON UPDATE no action ON DELETE no action
);
--> statement-breakpoint
CREATE TABLE `user_engagement` (
	`id` integer PRIMARY KEY AUTOINCREMENT NOT NULL,
	`user_id` integer NOT NULL,
	`chat_id` integer NOT NULL,
	`message_count` integer DEFAULT 0 NOT NULL,
	`command_count` integer DEFAULT 0 NOT NULL,
	`reply_count` integer DEFAULT 0 NOT NULL,
	`mention_count` integer DEFAULT 0 NOT NULL,
	`last_active` integer NOT NULL,
	`daily_active_streak` integer DEFAULT 0 NOT NULL,
	`average_response_time` integer,
	`created_at` integer DEFAULT CURRENT_TIMESTAMP NOT NULL,
	`updated_at` integer DEFAULT CURRENT_TIMESTAMP NOT NULL
);
--> statement-breakpoint
ALTER TABLE `group_configs` ADD `summary_format` text DEFAULT 'markdown' NOT NULL;--> statement-breakpoint
ALTER TABLE `group_configs` ADD `language` text DEFAULT 'en' NOT NULL;--> statement-breakpoint
ALTER TABLE `group_configs` ADD `schema_version` integer DEFAULT 1 NOT NULL;--> statement-breakpoint
ALTER TABLE `group_configs` ADD `max_daily_tokens` integer;--> statement-breakpoint
ALTER TABLE `group_configs` ADD `max_summary_tokens` integer;--> statement-breakpoint
ALTER TABLE `group_configs` ADD `token_usage_alert_percent` integer;--> statement-breakpoint
ALTER TABLE `messages` ADD `sentiment_score` integer;--> statement-breakpoint
ALTER TABLE `messages` ADD `embedding` text;--> statement-breakpoint
ALTER TABLE `summaries` ADD `format` text DEFAULT 'markdown' NOT NULL;
</document_content>
</document>
<document index="14">
<source>src/db/migrations/meta/0000_snapshot.json</source>
<document_content>
{
  "version": "6",
  "dialect": "sqlite",
  "id": "20648dbb-3696-4d8f-8a0a-6051137c6467",
  "prevId": "00000000-0000-0000-0000-000000000000",
  "tables": {
    "group_configs": {
      "name": "group_configs",
      "columns": {
        "id": {
          "name": "id",
          "type": "integer",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": true
        },
        "chat_id": {
          "name": "chat_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "summary_interval": {
          "name": "summary_interval",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 21600
        },
        "min_messages_for_summary": {
          "name": "min_messages_for_summary",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 10
        },
        "is_active": {
          "name": "is_active",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": true
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "CURRENT_TIMESTAMP"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "CURRENT_TIMESTAMP"
        }
      },
      "indexes": {
        "group_configs_chat_id_unique": {
          "name": "group_configs_chat_id_unique",
          "columns": [
            "chat_id"
          ],
          "isUnique": true
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "messages": {
      "name": "messages",
      "columns": {
        "id": {
          "name": "id",
          "type": "integer",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": true
        },
        "message_id": {
          "name": "message_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "chat_id": {
          "name": "chat_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "user_id": {
          "name": "user_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "username": {
          "name": "username",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "content": {
          "name": "content",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "timestamp": {
          "name": "timestamp",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "thread_id": {
          "name": "thread_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "reply_to_message_id": {
          "name": "reply_to_message_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "CURRENT_TIMESTAMP"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "summaries": {
      "name": "summaries",
      "columns": {
        "id": {
          "name": "id",
          "type": "integer",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": true
        },
        "chat_id": {
          "name": "chat_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "content": {
          "name": "content",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "message_count": {
          "name": "message_count",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "start_timestamp": {
          "name": "start_timestamp",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "end_timestamp": {
          "name": "end_timestamp",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "tokens_used": {
          "name": "tokens_used",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "CURRENT_TIMESTAMP"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    }
  },
  "views": {},
  "enums": {},
  "_meta": {
    "schemas": {},
    "tables": {},
    "columns": {}
  },
  "internal": {
    "indexes": {}
  }
}
</document_content>
</document>
<document index="15">
<source>src/db/migrations/meta/0001_snapshot.json</source>
<document_content>
{
  "version": "6",
  "dialect": "sqlite",
  "id": "3d140529-e6ce-455e-8819-76f6befa91c9",
  "prevId": "20648dbb-3696-4d8f-8a0a-6051137c6467",
  "tables": {
    "group_configs": {
      "name": "group_configs",
      "columns": {
        "id": {
          "name": "id",
          "type": "integer",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": true
        },
        "chat_id": {
          "name": "chat_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "summary_interval": {
          "name": "summary_interval",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 21600
        },
        "min_messages_for_summary": {
          "name": "min_messages_for_summary",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 10
        },
        "is_active": {
          "name": "is_active",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": true
        },
        "summary_format": {
          "name": "summary_format",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'markdown'"
        },
        "language": {
          "name": "language",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'en'"
        },
        "schema_version": {
          "name": "schema_version",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 1
        },
        "max_daily_tokens": {
          "name": "max_daily_tokens",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "max_summary_tokens": {
          "name": "max_summary_tokens",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "token_usage_alert_percent": {
          "name": "token_usage_alert_percent",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "CURRENT_TIMESTAMP"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "CURRENT_TIMESTAMP"
        }
      },
      "indexes": {
        "group_configs_chat_id_unique": {
          "name": "group_configs_chat_id_unique",
          "columns": [
            "chat_id"
          ],
          "isUnique": true
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "message_references": {
      "name": "message_references",
      "columns": {
        "id": {
          "name": "id",
          "type": "integer",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": true
        },
        "source_message_id": {
          "name": "source_message_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "target_message_id": {
          "name": "target_message_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "reference_type": {
          "name": "reference_type",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "resolved_username": {
          "name": "resolved_username",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "CURRENT_TIMESTAMP"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "messages": {
      "name": "messages",
      "columns": {
        "id": {
          "name": "id",
          "type": "integer",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": true
        },
        "message_id": {
          "name": "message_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "chat_id": {
          "name": "chat_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "user_id": {
          "name": "user_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "username": {
          "name": "username",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "content": {
          "name": "content",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "timestamp": {
          "name": "timestamp",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "thread_id": {
          "name": "thread_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "reply_to_message_id": {
          "name": "reply_to_message_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "sentiment_score": {
          "name": "sentiment_score",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "CURRENT_TIMESTAMP"
        },
        "embedding": {
          "name": "embedding",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "summaries": {
      "name": "summaries",
      "columns": {
        "id": {
          "name": "id",
          "type": "integer",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": true
        },
        "chat_id": {
          "name": "chat_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "content": {
          "name": "content",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "message_count": {
          "name": "message_count",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "start_timestamp": {
          "name": "start_timestamp",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "end_timestamp": {
          "name": "end_timestamp",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "tokens_used": {
          "name": "tokens_used",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "format": {
          "name": "format",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'markdown'"
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "CURRENT_TIMESTAMP"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "summary_feedback": {
      "name": "summary_feedback",
      "columns": {
        "id": {
          "name": "id",
          "type": "integer",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": true
        },
        "summary_id": {
          "name": "summary_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "chat_id": {
          "name": "chat_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "user_id": {
          "name": "user_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "rating": {
          "name": "rating",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "feedback_text": {
          "name": "feedback_text",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "CURRENT_TIMESTAMP"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "summary_feedback_summary_id_summaries_id_fk": {
          "name": "summary_feedback_summary_id_summaries_id_fk",
          "tableFrom": "summary_feedback",
          "tableTo": "summaries",
          "columnsFrom": [
            "summary_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "user_engagement": {
      "name": "user_engagement",
      "columns": {
        "id": {
          "name": "id",
          "type": "integer",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": true
        },
        "user_id": {
          "name": "user_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "chat_id": {
          "name": "chat_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "message_count": {
          "name": "message_count",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "command_count": {
          "name": "command_count",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "reply_count": {
          "name": "reply_count",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "mention_count": {
          "name": "mention_count",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "last_active": {
          "name": "last_active",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "daily_active_streak": {
          "name": "daily_active_streak",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "average_response_time": {
          "name": "average_response_time",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "CURRENT_TIMESTAMP"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "CURRENT_TIMESTAMP"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    }
  },
  "views": {},
  "enums": {},
  "_meta": {
    "schemas": {},
    "tables": {},
    "columns": {}
  },
  "internal": {
    "indexes": {}
  }
}
</document_content>
</document>
<document index="16">
<source>src/db/migrations/meta/_journal.json</source>
<document_content>
{
  "version": "7",
  "dialect": "sqlite",
  "entries": [
    {
      "idx": 0,
      "version": "6",
      "when": 1736436412895,
      "tag": "0000_first_golden_guardian",
      "breakpoints": true
    },
    {
      "idx": 1,
      "version": "6",
      "when": 1737821853215,
      "tag": "0001_neat_katie_power",
      "breakpoints": true
    }
  ]
}
</document_content>
</document>
<document index="17">
<source>src/db/repositories/engagement.ts</source>
<document_content>
import { db } from '../index';
import { userEngagement } from '../schema';
import { eq, and, sql } from 'drizzle-orm';

export interface EngagementMetrics {
  userId: number;
  chatId: number;
  messageCount?: number;
  commandCount?: number;
  replyCount?: number;
  mentionCount?: number;
  lastActive?: Date;
  dailyActiveStreak?: number;
  averageResponseTime?: number;
}

export class UserEngagementRepository {
  async upsertMetrics(metrics: EngagementMetrics) {
    const now = new Date();
    
    const [updated] = await db
      .insert(userEngagement)
      .values({
        userId: metrics.userId,
        chatId: metrics.chatId,
        messageCount: metrics.messageCount ?? 0,
        commandCount: metrics.commandCount ?? 0,
        replyCount: metrics.replyCount ?? 0,
        mentionCount: metrics.mentionCount ?? 0,
        lastActive: metrics.lastActive?.getTime() ?? now.getTime(),
        dailyActiveStreak: metrics.dailyActiveStreak ?? 0,
        averageResponseTime: metrics.averageResponseTime,
        updatedAt: now.getTime(),
      })
      .onConflictDoUpdate({
        target: [userEngagement.userId, userEngagement.chatId],
        set: {
          messageCount: sql`${userEngagement.messageCount} + excluded.message_count`,
          commandCount: sql`${userEngagement.commandCount} + excluded.command_count`,
          replyCount: sql`${userEngagement.replyCount} + excluded.reply_count`,
          mentionCount: sql`${userEngagement.mentionCount} + excluded.mention_count`,
          lastActive: sql`excluded.last_active`,
          dailyActiveStreak: sql`excluded.daily_active_streak`,
          averageResponseTime: sql`excluded.average_response_time`,
          updatedAt: sql`CURRENT_TIMESTAMP`,
        },
      })
      .returning();

    return updated;
  }

  async getMetrics(userId: number, chatId: number) {
    const [metrics] = await db
      .select()
      .from(userEngagement)
      .where(
        and(
          eq(userEngagement.userId, userId),
          eq(userEngagement.chatId, chatId)
        )
      );
    
    return metrics;
  }

  async updateActiveStreak(userId: number, chatId: number) {
    const [metrics] = await db
      .select()
      .from(userEngagement)
      .where(
        and(
          eq(userEngagement.userId, userId),
          eq(userEngagement.chatId, chatId)
        )
      );

    if (!metrics) return;

    const lastActiveDate = new Date(metrics.lastActive);
    const now = new Date();
    const daysSinceLastActive = Math.floor(
      (now.getTime() - lastActiveDate.getTime()) / (1000 * 60 * 60 * 24)
    );

    let newStreak = metrics.dailyActiveStreak;
    if (daysSinceLastActive <= 1) {
      newStreak += 1;
    } else {
      newStreak = 1;
    }

    await db
      .update(userEngagement)
      .set({
        dailyActiveStreak: newStreak,
        lastActive: now.getTime(),
        updatedAt: now.getTime(),
      })
      .where(
        and(
          eq(userEngagement.userId, userId),
          eq(userEngagement.chatId, chatId)
        )
      );
  }
}

</document_content>
</document>
<document index="18">
<source>src/db/repositories/group-configs.ts</source>
<document_content>
import { eq, sql, and } from 'drizzle-orm';
import { db } from '../index';
import { groupConfigs, summaries } from '../schema';

export interface GroupConfig {
  chatId: number;
  summaryInterval?: number;
  minMessagesForSummary?: number;
  isActive?: boolean;
  language?: string;
  schemaVersion?: number;
  maxDailyTokens?: number;
  maxSummaryTokens?: number;
  tokenUsageAlert?: number;
}

export class GroupConfigsRepository {
  /**
   * Create or update a group configuration
   */
  async upsert(config: GroupConfig) {
    const values = {
      chatId: config.chatId,
      summaryInterval: config.summaryInterval,
      minMessagesForSummary: config.minMessagesForSummary,
      isActive: config.isActive,
      maxDailyTokens: config.maxDailyTokens,
      maxSummaryTokens: config.maxSummaryTokens,
      tokenUsageAlert: config.tokenUsageAlert,
      language: config.language,
      schemaVersion: config.schemaVersion
    };

    // Remove undefined values
    Object.keys(values).forEach(key => {
      if (values[key] === undefined) {
        delete values[key];
      }
    });

    const [created] = await db.insert(groupConfigs)
      .values(values)
      .onConflictDoUpdate({
        target: groupConfigs.chatId,
        set: values
      })
      .returning();

    return created;
  }

  /**
   * Get configuration for a specific chat
   */
  async getByChatId(chatId: number) {
    return await db.query.groupConfigs.findFirst({
      where: eq(groupConfigs.chatId, chatId),
    });
  }

  /**
   * Get all active group configurations
   */
  async getAllActive() {
    return await db.query.groupConfigs.findMany({
      where: eq(groupConfigs.isActive, true),
    });
  }

  /**
   * Update group configuration
   */
  async update(chatId: number, config: Partial<GroupConfig>) {
    const [updated] = await db.update(groupConfigs)
      .set({
        summaryInterval: config.summaryInterval,
        minMessagesForSummary: config.minMessagesForSummary,
        isActive: config.isActive,
      })
      .where(eq(groupConfigs.chatId, chatId))
      .returning();

    return updated;
  }

  /**
   * Check token usage and trigger alerts if needed
   */
  async checkTokenUsage(chatId: number) {
    const config = await this.getByChatId(chatId);
    if (!config?.maxDailyTokens || !config.tokenUsageAlert) {
      return null;
    }

    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const result = await db
      .select({ 
        totalTokens: sql<number>`sum(tokens_used)`,
        lastAlert: sql<number>`max(case when alert_sent = 1 then created_at end)`
      })
      .from(summaries)
      .where(and(
        eq(summaries.chatId, chatId),
        sql`created_at >= ${today.getTime()}`
      ));

    const totalTokens = result[0]?.totalTokens || 0;
    const alertThreshold = config.maxDailyTokens * (config.tokenUsageAlert / 100);
    const lastAlert = result[0]?.lastAlert;
    const shouldAlert = totalTokens >= alertThreshold && 
                       (!lastAlert || (Date.now() - lastAlert) > 3600000); // 1 hour cooldown

    if (shouldAlert) {
      await db.update(summaries)
        .set({ alertSent: true })
        .where(eq(summaries.chatId, chatId));
    }

    return shouldAlert ? {
      currentUsage: totalTokens,
      limit: config.maxDailyTokens,
      percentage: (totalTokens / config.maxDailyTokens) * 100,
      shouldAlert
    } : null;
  }

  async generateCostReport(chatId: number, startDate?: Date, endDate: Date = new Date()) {
    const start = startDate || new Date(endDate.getTime() - (30 * 24 * 60 * 60 * 1000)); // Default 30 days

    const rawData = await db
      .select({
        date: sql<string>`date(datetime(created_at/1000, 'unixepoch'))`,
        totalTokens: sql<number>`sum(tokens_used)`,
        summaryCount: sql<number>`count(*)`,
        avgTokensPerSummary: sql<number>`avg(tokens_used)`
      })
      .from(summaries)
      .where(and(
        eq(summaries.chatId, chatId),
        sql`created_at >= ${start.getTime()}`,
        sql`created_at <= ${endDate.getTime()}`
      ))
      .groupBy(sql`date`)
      .orderBy(sql`date`);

    // Format the report
    const totalTokens = rawData.reduce((sum, day) => sum + (day.totalTokens || 0), 0);
    const totalSummaries = rawData.reduce((sum, day) => sum + day.summaryCount, 0);
    
    return {
      period: {
        start: start.toISOString().split('T')[0],
        end: endDate.toISOString().split('T')[0]
      },
      totals: {
        tokens: totalTokens,
        summaries: totalSummaries,
        avgTokensPerSummary: totalSummaries ? Math.round(totalTokens / totalSummaries) : 0
      },
      dailyStats: rawData.map(day => ({
        date: day.date,
        tokens: day.totalTokens || 0,
        summaries: day.summaryCount,
        avgTokens: Math.round(day.avgTokensPerSummary || 0)
      }))
    };
  }
}

</document_content>
</document>
<document index="19">
<source>src/db/repositories/index.ts</source>
<document_content>
export * from './messages';
export * from './group-configs'; 
export * from './engagement';

</document_content>
</document>
<document index="20">
<source>src/db/repositories/messages.ts</source>
<document_content>
import { eq, and, desc, sql } from 'drizzle-orm';
import { db } from '../index';
import { messages, messageReferences } from '../schema';
import type { Message } from '../../types/message';

export class MessagesRepository {
  /**
   * Create a new message record
   */
  async create(message: Message) {
    const [created] = await db.insert(messages).values({
      messageId: message.messageId,
      chatId: message.chatId,
      userId: message.userId,
      username: message.username,
      content: message.content,
      timestamp: message.timestamp,
      threadId: message.threadId,
      replyToMessageId: message.replyToMessageId,
      sentimentScore: message.sentimentScore,
    }).returning();

    // Store message references if they exist
    if (message.references?.length) {
      await db.insert(messageReferences).values(
        message.references.map(ref => ({
          sourceMessageId: created.id,
          targetMessageId: ref.targetMessageId,
          referenceType: ref.type,
          resolvedUsername: ref.resolvedUsername,
        }))
      );
    }

    return created;
  }

  /**
   * Get a message by its Telegram message ID and chat ID
   */
  async getByMessageId(messageId: number, chatId: number) {
    const message = await db.query.messages.findFirst({
      where: and(
        eq(messages.messageId, messageId),
        eq(messages.chatId, chatId)
      ),
    });

    return message;
  }

  /**
   * Get messages for a specific chat within a time range
   */
  async getByChatId(chatId: number, options?: {
    startTime?: Date;
    endTime?: Date;
    limit?: number;
  }) {
    let conditions = [eq(messages.chatId, chatId)];

    if (options?.startTime) {
      conditions.push(sql`${messages.timestamp} >= ${options.startTime.getTime()}`);
    }

    if (options?.endTime) {
      conditions.push(sql`${messages.timestamp} <= ${options.endTime.getTime()}`);
    }

    const query = db.select().from(messages)
      .where(and(...conditions))
      .orderBy(desc(messages.timestamp));

    if (options?.limit) {
      query.limit(options.limit);
    }

    return await query;
  }

  /**
   * Get messages that are part of a specific thread
   */
  async getByThreadId(threadId: number, chatId: number) {
    return await db.select().from(messages)
      .where(and(
        eq(messages.threadId, threadId),
        eq(messages.chatId, chatId)
      ))
      .orderBy(desc(messages.timestamp));
  }

  /**
   * Delete messages older than a specified date for a chat
   */
  async deleteOlderThan(chatId: number, date: Date) {
    return await db.delete(messages)
      .where(and(
        eq(messages.chatId, chatId),
        sql`${messages.timestamp} < ${date.getTime()}`
      ));
  }

  /**
   * Search messages with fuzzy matching
   */
  async searchMessages(chatId: number, query: string, options?: {
    startTime?: Date;
    endTime?: Date;
    limit?: number;
    similarityThreshold?: number;
  }) {
    let conditions = [
      eq(messages.chatId, chatId),
      options?.similarityThreshold 
        ? sql`similarity(${messages.content}, ${query}) > ${options.similarityThreshold}`
        : sql`${messages.content} LIKE '%' || ${query} || '%'`
    ];

    if (options?.startTime) {
      conditions.push(sql`${messages.timestamp} >= ${options.startTime.getTime()}`);
    }

    if (options?.endTime) {
      conditions.push(sql`${messages.timestamp} <= ${options.endTime.getTime()}`);
    }

    const searchQuery = db.select()
      .from(messages)
      .where(and(...conditions))
      .orderBy(desc(messages.timestamp));

    if (options?.limit) {
      searchQuery.limit(options.limit);
    }

    return await searchQuery;
  }
  /**
   * Get references for a specific message
   */
  async getMessageReferences(messageId: number) {
    return await db.query.messageReferences.findMany({
      where: eq(messageReferences.sourceMessageId, messageId),
    });
  }

  /**
   * Find messages similar to the given embedding vector
   */
  async findSimilarMessages(chatId: number, embedding: number[], options?: {
    startTime?: Date;
    endTime?: Date;
    threshold?: number;
    limit?: number;
  }) {
    let conditions = [
      eq(messages.chatId, chatId),
      sql`cosine_similarity(${messages.embedding}, ${JSON.stringify(embedding)}) > ${options?.threshold ?? 0.78}`
    ];

    if (options?.startTime) {
      conditions.push(sql`${messages.timestamp} >= ${options.startTime.getTime()}`);
    }

    if (options?.endTime) {
      conditions.push(sql`${messages.timestamp} <= ${options.endTime.getTime()}`);
    }

    const query = db.select()
      .from(messages)
      .where(and(...conditions))
      .orderBy(desc(messages.timestamp));

    if (options?.limit) {
      query.limit(options.limit);
    }

    return await query;
  }
}

</document_content>
</document>
<document index="21">
<source>src/bot/index.ts</source>
<document_content>
import { Bot } from "grammy";
import { config } from "dotenv";
import { initializeDatabase } from "../db/init";
import { createMessageLogger } from "./middleware/message-logger";
import { rateLimiter } from "./middleware/rate-limiter";
import { initializeSummaryScheduler, triggerManualSummary } from "../llm/scheduler";
import { db } from "../db";
import { groupConfigs } from "../db/schema";
import { eq } from "drizzle-orm";

// Load environment variables
config();

if (!process.env.TELEGRAM_BOT_TOKEN) {
  throw new Error("TELEGRAM_BOT_TOKEN environment variable is required");
}

// Create bot instance
export const bot = new Bot(process.env.TELEGRAM_BOT_TOKEN);

// Debug mode detection
const isDebugMode = process.env.NODE_ENV === 'development' || process.argv.includes('--debug');

async function isGroupAdmin(chatId: number, userId: number): Promise<boolean> {
  try {
    const member = await bot.api.getChatMember(chatId, userId);
    if (isDebugMode) {
      // In debug mode, only allow the group creator
      return member.status === "creator";
    }
    // In production, allow both creators and administrators
    return ["creator", "administrator"].includes(member.status);
  } catch (error) {
    console.error("Error checking admin status:", error);
    return false;
  }
}

// Initialize bot
export async function initializeBot() {
  try {
    // Initialize database
    await initializeDatabase();

    // Initialize summary scheduler
    await initializeSummaryScheduler();

    // Add middleware
    bot.use(rateLimiter());
    bot.use(createMessageLogger());

    // Handle bot being added to a group
    bot.on("my_chat_member", async (ctx) => {
      if (ctx.chat.type === "group" || ctx.chat.type === "supergroup") {
        const chatId = ctx.chat.id;
        
        // Check if config already exists
        const existingConfig = await db.query.groupConfigs.findFirst({
          where: eq(groupConfigs.chatId, chatId),
        });

        if (!existingConfig) {
          // Create new group configuration
          await db.insert(groupConfigs).values({
            chatId: chatId,
            summaryInterval: 21600, // 6 hours in seconds
            minMessagesForSummary: 10,
            isActive: true,
          });

          await ctx.reply("Thanks for adding me! I'll help you track and summarize conversations in this group.");
        }
      }
    });

    // Add command handlers
    bot.command("start", (ctx) => ctx.reply("Welcome to Zenopsis! I will help you track and summarize group chat conversations."));
    bot.command("help", (ctx) => ctx.reply(
      "Available commands:\n" +
      "/start - Start the bot\n" +
      "/help - Show this help message\n" +
      `/summary - Generate a summary of recent messages (${isDebugMode ? 'owner' : 'admin'} only)`
    ));

    // Add summary command
    bot.command("summary", async (ctx) => {
      try {
        const chatId = ctx.chat.id;
        const userId = ctx.from?.id;

        if (!userId) {
          await ctx.reply("Sorry, I couldn't identify the user.");
          return;
        }

        // Check if user is admin/owner
        if (ctx.chat.type === "group" || ctx.chat.type === "supergroup") {
          const isAdmin = await isGroupAdmin(chatId, userId);
          if (!isAdmin) {
            await ctx.reply(`Sorry, only group ${isDebugMode ? 'owner' : 'administrators'} can use this command.`);
            return;
          }
        }

        // Ensure group config exists
        let config = await db.query.groupConfigs.findFirst({
          where: eq(groupConfigs.chatId, chatId),
        });

        if (!config && (ctx.chat.type === "group" || ctx.chat.type === "supergroup")) {
          // Create config if it doesn't exist
          await db.insert(groupConfigs).values({
            chatId: chatId,
            summaryInterval: 21600,
            minMessagesForSummary: 10,
            isActive: true,
          });
        }

        await ctx.reply("Generating summary... Please wait.");
        const summary = await triggerManualSummary(chatId);
        
        // Check token usage before sending summary
        const usage = await groupConfigs.checkTokenUsage(chatId);
        if (usage?.shouldAlert) {
          const alertMsg = [
            `âš ï¸ *Token Usage Alert*`,
            `Current usage: ${usage.percentage.toFixed(1)}% of daily limit`,
            `${usage.currentUsage.toLocaleString()} / ${usage.limit.toLocaleString()} tokens used`,
            '',
            `To prevent service interruption:`,
            `â€¢ Increase your daily token limit, or`,
            `â€¢ Reduce summary frequency`
          ].join('\n');
          
          await ctx.reply(alertMsg, { parse_mode: 'Markdown' });
        }

        if (summary) {
          await ctx.reply(summary, { parse_mode: 'Markdown' });
        } else {
          await ctx.reply("Not enough messages to generate a summary. Please try again later when there are more messages.");
        }
      } catch (error) {
        console.error("Error generating summary:", error);
        await ctx.reply("Sorry, I couldn't generate a summary at this time. Please try again later.");
      }
    });

    // Log startup mode
    console.log(`Bot started successfully in ${isDebugMode ? 'debug' : 'production'} mode`);
    
    // Start the bot
    await bot.start();
  } catch (error) {
    console.error("Failed to initialize bot:", error);
    throw error;
  }
} 

</document_content>
</document>
<document index="22">
<source>src/bot/middleware/message-logger.ts</source>
<document_content>
import { Context, Middleware } from 'grammy';
import { MessagesRepository } from '../../db/repositories';

const messagesRepo = new MessagesRepository();

export function createMessageLogger(): Middleware<Context> {
  return async (ctx, next) => {
    try {
      // Only process text messages from group chats
      if (!ctx.message?.text || !ctx.chat?.id || ctx.chat.type === 'private') {
        return next();
      }

      // Skip bot commands
      if (ctx.message.text.startsWith('/')) {
        return next();
      }

      // Save message to database
      await messagesRepo.create({
        messageId: ctx.message.message_id,
        chatId: ctx.chat.id,
        userId: ctx.from?.id || 0,
        username: ctx.from?.username,
        content: ctx.message.text,
        timestamp: ctx.message.date * 1000,
        threadId: ctx.message.message_thread_id,
        replyToMessageId: ctx.message.reply_to_message?.message_id,
      });

      return next();
    } catch (error) {
      console.error('Error saving message to database:', error);
      return next();
    }
  };
} 
</document_content>
</document>
<document index="23">
<source>src/bot/middleware/messageHandler.ts</source>
<document_content>
import { Context, Middleware } from "grammy";

import { Message, MessageReference, ReferenceType } from '../../types/message';

interface MessageMetadata {
  messageId: number;
  chatId: number;
  senderId: number;
  senderName: string;
  timestamp: Date;
  text: string | null;
  isCommand: boolean;
  isFromBot: boolean;
}

/**
 * Extracts essential metadata from a message
 */
function extractMessageMetadata(ctx: Context): MessageMetadata | null {
  const message = ctx.message;
  if (!message) return null;

  return {
    messageId: message.message_id,
    chatId: message.chat.id,
    senderId: message.from?.id ?? 0,
    senderName: message.from?.first_name ?? "Unknown",
    timestamp: new Date(message.date * 1000),
    text: message.text ?? message.caption ?? null,
    isCommand: !!message.text?.startsWith("/"),
    isFromBot: message.from?.is_bot ?? false,
  };
}

/**
 * Validates if a message should be processed
 */
async function detectMessageReferences(ctx: Context): Promise<MessageReference[]> {
  const references: MessageReference[] = [];
  
  // Detect reply-to references
  if (ctx.message?.reply_to_message) {
    references.push({
      type: ReferenceType.REPLY,
      targetMessageId: ctx.message.reply_to_message.message_id,
    });
  }

  // Add similarity-based thread detection
  if (ctx.message?.text) {
    const messagesRepo = new MessagesRepository();
    const embedding = await generateTextEmbedding(ctx.message.text);
    const similarMessages = await messagesRepo.findSimilarMessages(
      ctx.chat.id,
      embedding,
      { 
        threshold: 0.85,
        limit: 1,
        startTime: new Date(Date.now() - 24 * 60 * 60 * 1000) // Last 24 hours
      }
    );

    if (similarMessages.length > 0) {
      references.push({
        type: ReferenceType.CONTEXT,
        targetMessageId: similarMessages[0].messageId,
        contextType: 'similarity'
      });
    }
  }

  // Detect explicit thread references
  if (ctx.message?.text) {
    const threadMatch = ctx.message.text.match(/(?:re:|thread:)\s*(\d+)/i);
    if (threadMatch) {
      references.push({
        type: ReferenceType.THREAD,
        targetMessageId: parseInt(threadMatch[1], 10),
      });
    }
  }

  // Detect context-based thread references
  if (ctx.message?.text) {
    const contextKeywords = {
      project: ['project', 'task', 'milestone', 'deadline'],
      meeting: ['meeting', 'call', 'discussion', 'sync'],
      support: ['issue', 'problem', 'help', 'error'],
      event: ['event', 'planning', 'schedule', 'organize']
    };

    for (const [context, keywords] of Object.entries(contextKeywords)) {
      if (keywords.some(keyword => ctx.message!.text!.toLowerCase().includes(keyword))) {
        references.push({
          type: ReferenceType.CONTEXT,
          targetMessageId: -1,
          contextType: context
        });
        break;
      }
    }
  }

  // Detect mentions (@username)
  if (ctx.message?.text) {
    const mentionRegex = /@([a-zA-Z0-9_]{5,32})/g;
    let matches: RegExpExecArray | null;
    
    while ((matches = mentionRegex.exec(ctx.message.text)) !== null) {
      references.push({
        type: ReferenceType.MENTION,
        targetMessageId: -1,
        resolvedUsername: matches[1]
      });
    }
  }

  return references;
}

function shouldProcessMessage(metadata: MessageMetadata): boolean {
  // Skip bot commands and bot messages
  if (metadata.isCommand || metadata.isFromBot) return false;
  
  // Skip empty messages
  if (!metadata.text?.trim()) return false;
  
  return true;
}

/**
 * Message capture middleware
 */
export const messageHandler: Middleware<Context> = async (ctx, next) => {
  try {
    const metadata = extractMessageMetadata(ctx);
    
    if (metadata && shouldProcessMessage(metadata)) {
      // Detect and add references
      const references = detectMessageReferences(ctx);
      
      // Create full message object
      const message: Message = {
        messageId: metadata.messageId,
        chatId: metadata.chatId,
        userId: metadata.senderId,
        username: metadata.senderName,
        content: metadata.text || '',
        timestamp: metadata.timestamp.getTime(),
        references
      };

      // TODO: Store message with references
      console.log('Processing message with references:', message);
    }
  } catch (error) {
    console.error("Error processing message:", error);
  }

  await next();
}; 

</document_content>
</document>
<document index="24">
<source>src/bot/middleware/rate-limiter.ts</source>
<document_content>
import { Context, NextFunction } from "grammy";

interface RateLimit {
  count: number;
  timestamp: number;
}

const WINDOW_MS = 60000; // 1 minute
const MAX_REQUESTS = 5;

export const rateLimiter = () => {
  const limits = new Map<string, RateLimit>();

  return async (ctx: Context, next: NextFunction) => {
    const now = Date.now();
    const key = `${ctx.chat?.id}:${ctx.from?.id}`;
    
    // Clean up old entries
    for (const [storedKey, limit] of limits.entries()) {
      if (now - limit.timestamp > WINDOW_MS) {
        limits.delete(storedKey);
      }
    }

    const currentLimit = limits.get(key) || { count: 0, timestamp: now };
    
    if (now - currentLimit.timestamp > WINDOW_MS) {
      // Reset if window expired
      currentLimit.count = 1;
      currentLimit.timestamp = now;
    } else if (currentLimit.count >= MAX_REQUESTS) {
      await ctx.reply("Rate limit exceeded. Please wait a minute before sending more messages.");
      return;
    } else {
      currentLimit.count++;
    }
    
    limits.set(key, currentLimit);
    await next();
  };
};

</document_content>
</document>
<document index="25">
<source>tests/unit/repositories/message-references.test.ts</source>
<document_content>
import { describe, test, expect, beforeEach } from 'bun:test';
import { db } from '../../../src/db';
import { messageReferences } from '../../../src/db/schema';
import { cleanDatabase, setupTestDatabase } from '../../helpers/test-utils';
import { migrate } from 'drizzle-orm/bun-sqlite/migrator';
import { sql } from 'drizzle-orm';

describe('Message References Repository', () => {
  beforeEach(async () => {
    await cleanDatabase();
    await migrate(db, { migrationsFolder: './src/db/migrations' });
  });

  test('should create message reference', async () => {
    const reference = {
      sourceMessageId: 123,
      targetMessageId: 456,
      referenceType: 'reply',
      resolvedUsername: 'test_user'
    };

    const [created] = await db.insert(messageReferences)
      .values(reference)
      .returning();

    expect(created.sourceMessageId).toBe(reference.sourceMessageId);
    expect(created.targetMessageId).toBe(reference.targetMessageId);
    expect(created.referenceType).toBe(reference.referenceType);
    expect(created.resolvedUsername).toBe(reference.resolvedUsername);
  });

  test('should retrieve message reference', async () => {
    const { createMessage } = await setupTestDatabase();
    
    const source = await createMessage();
    const target = await createMessage();
    
    const reference = {
      sourceMessageId: source[0].messageId,
      targetMessageId: target[0].messageId,
      referenceType: 'mention',
      resolvedUsername: 'mentioned_user'
    };

    await db.insert(messageReferences).values(reference);

    const [retrieved] = await db.select()
      .from(messageReferences)
      .where(sql`source_message_id = ${source[0].messageId}`);

    expect(retrieved).toBeDefined();
    expect(retrieved.referenceType).toBe('mention');
    expect(retrieved.resolvedUsername).toBe('mentioned_user');
  });

  test('should delete message reference', async () => {
    const reference = {
      sourceMessageId: 789,
      targetMessageId: 101,
      referenceType: 'edit',
    };

    const [created] = await db.insert(messageReferences)
      .values(reference)
      .returning();

    await db.delete(messageReferences)
      .where(sql`id = ${created.id}`);

    const [deleted] = await db.select()
      .from(messageReferences)
      .where(sql`id = ${created.id}`);

    expect(deleted).toBeUndefined();
  });
});

</document_content>
</document>
<document index="26">
<source>tests/unit/repositories/messages.test.ts</source>
<document_content>
import { expect, test, describe, beforeEach } from "bun:test";
import { MessagesRepository } from "../../../src/db/repositories/messages";
import { db } from "../../../src/db";
import { messages, messageReferences } from "../../../src/db/schema";

describe("MessagesRepository", () => {
  let repository: MessagesRepository;

  beforeEach(async () => {
    // Clear test database
    await db.delete(messageReferences);
    await db.delete(messages);
    repository = new MessagesRepository();
  });

  test("stores message with multiple references", async () => {
    const message = await repository.create({
      messageId: 1,
      chatId: 1,
      userId: 1,
      username: "testuser",
      content: "Test message with @mention and reply",
      timestamp: Date.now(),
      references: [
        { type: "reply", targetMessageId: 2 },
        { type: "mention", resolvedUsername: "mentioned_user" }
      ]
    });

    const refs = await repository.getMessageReferences(message.id);
    expect(refs).toHaveLength(2);
    expect(refs[0].referenceType).toBe("reply");
    expect(refs[1].referenceType).toBe("mention");
  });

  test("findSimilarMessages returns messages above threshold", async () => {
    const testEmbedding = new Array(1536).fill(0.1);
    
    await repository.create({
      messageId: 1,
      chatId: 1,
      userId: 1,
      username: "testuser",
      content: "Similar message",
      timestamp: Date.now(),
      embedding: JSON.stringify(testEmbedding)
    });

    const results = await repository.findSimilarMessages(1, testEmbedding, {
      threshold: 0.8
    });

    expect(results).toHaveLength(1);
  });
});

</document_content>
</document>
<document index="27">
<source>tests/db/repositories/group-configs.test.ts</source>
<document_content>
import { describe, expect, test, beforeEach, afterEach } from "bun:test";
import { GroupConfigsRepository } from "../../../src/db/repositories/group-configs";
import { db } from "../../../src/db";
import { groupConfigs, summaries } from "../../../src/db/schema";

describe("GroupConfigsRepository", () => {
  let repo: GroupConfigsRepository;

  beforeEach(() => {
    repo = new GroupConfigsRepository();
  });

  afterEach(async () => {
    // Clean up test data
    await db.delete(groupConfigs);
  });

  test("upsert creates new config", async () => {
    const config = {
      chatId: 123,
      summaryInterval: 3600,
      minMessagesForSummary: 5,
      isActive: true
    };

    const result = await repo.upsert(config);

    expect(result).toBeDefined();
    expect(result.chatId).toBe(config.chatId);
    expect(result.summaryInterval).toBe(config.summaryInterval);
  });

  test("upsert updates existing config", async () => {
    // Create initial config
    const initial = await repo.upsert({
      chatId: 123,
      summaryInterval: 3600,
      isActive: true
    });

    // Update config
    const updated = await repo.upsert({
      chatId: 123,
      summaryInterval: 7200,
      isActive: false
    });

    expect(updated.summaryInterval).toBe(7200);
    expect(updated.isActive).toBe(false);
  });

  test("getByChatId returns null for non-existent chat", async () => {
    const result = await repo.getByChatId(999);
    expect(result).toBeUndefined();
  });

  test("getAllActive returns only active configs", async () => {
    await repo.upsert({ chatId: 1, isActive: true });
    await repo.upsert({ chatId: 2, isActive: false });
    await repo.upsert({ chatId: 3, isActive: true });

    const active = await repo.getAllActive();
    
    expect(active).toHaveLength(2);
    expect(active.map(c => c.chatId)).toEqual([1, 3]);
  });

  test("checkTokenUsage returns alert when threshold exceeded", async () => {
    const config = {
      chatId: 123,
      maxDailyTokens: 1000,
      tokenUsageAlert: 80 // Alert at 80%
    };

    await repo.upsert(config);

    // Simulate token usage
    await db.insert(summaries).values({
      chatId: 123,
      tokensUsed: 850, // 85% of limit
      content: "Test summary",
      messageCount: 10,
      startTimestamp: new Date().getTime(),
      endTimestamp: new Date().getTime(),
      format: 'markdown',
      alertSent: 0
    });

    const usage = await repo.checkTokenUsage(123);
    
    expect(usage).toBeDefined();
    expect(usage?.shouldAlert).toBe(true);
    expect(usage?.percentage).toBeGreaterThan(80);
  });
});

</document_content>
</document>
<document index="28">
<source>tests/helpers/test-utils.ts</source>
<document_content>
import { db } from "../../src/db";
import { messages, groupConfigs, summaries } from "../../src/db/schema";

export async function cleanDatabase() {
  await db.delete(messages);
  await db.delete(groupConfigs);
  await db.delete(summaries);
}

export function createTestMessage(overrides = {}) {
  return {
    messageId: Math.floor(Math.random() * 1000000),
    chatId: -1001234567890,
    userId: 123456789,
    username: "test_user",
    content: "Test message content",
    timestamp: Date.now(),
    ...overrides
  };
}

export function createTestConfig(overrides = {}) {
  return {
    chatId: -1001234567890,
    summaryInterval: 21600,
    minMessagesForSummary: 10,
    isActive: true,
    ...overrides
  };
}

export async function setupTestDatabase() {
  await cleanDatabase();
  return {
    createMessage: async (data = {}) => {
      const message = createTestMessage(data);
      return await db.insert(messages).values(message).returning();
    },
    createConfig: async (data = {}) => {
      const config = createTestConfig(data);
      return await db.insert(groupConfigs).values(config).returning();
    }
  };
}

</document_content>
</document>
<document index="29">
<source>drizzle.config.ts</source>
<document_content>
import type { Config } from 'drizzle-kit';
import { config } from 'dotenv';

config();

if (!process.env.DATABASE_URL) {
  throw new Error('DATABASE_URL environment variable is required');
}

export default {
  schema: './src/db/schema.ts',
  out: './src/db/migrations',
  dialect: 'sqlite',
  dbCredentials: {
    url: process.env.DATABASE_URL
  },
} satisfies Config; 
</document_content>
</document>
<document index="30">
<source>index.ts</source>
<document_content>
console.log("Hello via Bun!");
</document_content>
</document>
<document index="31">
<source>package.json</source>
<document_content>
{
  "name": "zenopsis",
  "version": "0.1.0",
  "type": "module",
  "scripts": {
    "start": "bun run src/index.ts",
    "dev": "bun --watch run src/index.ts",
    "type-check": "tsc --noEmit",
    "db:generate": "drizzle-kit generate",
    "db:push": "drizzle-kit push",
    "db:studio": "drizzle-kit studio",
    "test": "bun test",
    "test:watch": "bun test --watch",
    "test:coverage": "bun test --coverage"
  },
  "dependencies": {
    "@grammyjs/types": "^3.3.0",
    "@instructor-ai/instructor": "^1.5.0",
    "dotenv": "^16.3.1",
    "drizzle-kit": "^0.30.1",
    "drizzle-orm": "^0.38.3",
    "grammy": "^1.19.2",
    "openai": "^4.77.4",
    "zod": "^3.24.1"
  },
  "devDependencies": {
    "bun-types": "latest",
    "typescript": "^5.0.0",
    "bun-test": "^1.0.0",
    "@types/jest": "^29.5.0"
  }
}

</document_content>
</document>
<document index="32">
<source>ROADMAP.md</source>
<document_content>
# Zenopsis Development Roadmap

## MVP Phase (Core Functionality)

### Phase 1: Foundation Setup
- [x] Initialize TypeScript project with Bun
- [x] Set up project structure (/src folders)
- [x] Configure environment variables handling
- [x] Create basic bot connection using **Grammy**
- [x] Implement basic error handling and logging system
- [x] Add essential command handlers (/start, /help)

### Phase 2: Basic Message Monitoring
- [x] Implement basic message capture middleware
- [x] Store essential message metadata (sender, timestamp, chat_id)
- [x] Handle basic text messages:
  - [x] Pure text messages
  - [x] Text captions from media messages
  - [x] Basic message validation
  - [x] Filter out bot commands and bot messages

### Phase 3: Essential Database Integration
- [x] Set up Drizzle ORM with SQLite
- [x] Create minimal database schema for:
  - [x] Chat messages
  - [x] Group configurations
  - [x] Summary history
- [x] Create initial database migrations
- [x] Implement basic database connection
- [x] Add core CRUD operations for messages

### Phase 4: Basic OpenAI Integration
- [x] Set up OpenAI client with Instructor.js
- [x] Implement basic message batching
- [x] Create simple summary generation logic
- [x] Add basic rate limiting and token management
- [x] Implement essential error handling for API calls

### Phase 5: Basic Summary Generation
- [x] Create simple timer-based summary trigger
- [x] Implement basic message selection for summarization
- [x] Create minimal summary format
- [x] Add summary delivery to group chat
- [x] Implement manual summary trigger command
- [x] Add summary formatting options
- [x] Implement summary feedback collection

## Enhancement Phase (Post-MVP)

### Phase 6: Advanced Message Handling âœ“
- [x] Enhance message validation:
  - [x] Check for empty or whitespace-only messages
  - [x] Validate message length limits
  - [x] Enhanced bot message filtering
  - [x] Check message format and encoding
- [x] Implement message threading/conversation tracking:
  - [x] Handle explicit threading via Telegram replies
  - [x] Implement context-based thread detection (via detectMessageReferences)
  - [x] Time-based proximity analysis
  - [x] Text similarity matching (via findSimilarMessages)
  - [x] Name/mention detection

### Phase 7: Enhanced Reference System
- [x] Design message reference storage schema
- [x] Complete reference implementation:
  - [x] Reply tracking (messageReferences table)
  - [x] Mention handling (detectMessageReferences)
  - [x] Context links (similarity-based)
  - [x] Explicit thread references (threadId column)
- [x] Add topic detection and tracking
- [x] Create unified threading system
- [x] Add jump-to-message functionality

### Phase 8: Advanced Summary Features
- [x] Enhance summary schema:
  - [x] Define comprehensive metadata fields
  - [x] Create message reference structure
  - [x] Design topic categorization schema
  - [x] Add participant tracking
  - [x] Add schema versioning support
  - [x] Define data integrity rules:
    - [x] Required field constraints
    - [x] Data type validations
    - [x] Field length and format checks
    - [x] Reference integrity checks
- [x] Implement topic clustering (via `clustering.ts`)
- [x] Message clustering + confidence scoring
- [x] Integration with summary generation
- [x] Add cost tracking and limitations:
  - [x] Track API token usage (GroupConfigsRepository)
  - [x] Set configurable limits (maxDailyTokens)
  - [x] Implement usage alerts (threshold-based alerts with cooldown)
  - [x] Create cost reports (generateCostReport with daily/monthly analytics)

### Phase 9: Group Management
- [x] Add group-specific settings
- [x] Implement admin-only commands
- [x] Create group-specific preferences storage
- [x] Add usage statistics
- [x] Implement group welcome messages
- [x] Add group-specific summary schedules
- [x] Implement group-specific language settings (groupConfigs.language)

### Phase 10: Extended Features
- [x] Add support for additional message types:
  - [x] Images and photos (with caption extraction)
  - [x] Videos
  - [x] Voice messages
  - [x] Documents
  - [x] Stickers
- [x] Implement media content analysis (caption handling)
- [x] Add conversation topic detection
- [x] Implement sentiment analysis
- [x] Add multi-language support
- [x] Create user engagement metrics:
  - [x] Message count tracking
  - [x] Command usage tracking
  - [x] Reply and mention tracking
  - [x] Activity streaks
  - [x] Response time analytics
- [x] Implement conversation search:
  - [x] Time filters (MessagesRepository.searchMessages)
  - [x] Similarity thresholding
  - [x] Fuzzy matching

## Final Phases

### Phase 11: Testing and Documentation
- [ ] **Testing**:
  - [x] Basic unit tests for repositories (messages, references, group configs)
  - [ ] Additional integration/end-to-end tests
  - [ ] Performance/load testing
- [ ] **Documentation**:
  - [ ] API Reference
  - [ ] User Guide
  - [ ] Deployment Guide
  - [ ] Contributing Guidelines

### Phase 12: Production Deployment
- [x] Core Operational Features:
  - [x] Request logging middleware (via message-logger)
  - [x] Error tracking system (in bot handlers)
  - [x] Token usage monitoring (with alerts in GroupConfigsRepository)
- [x] Rate Limiting:
  - [x] Window-based rate limiting (60s window)
  - [x] Per-user/chat limits
  - [x] Automatic cleanup
  - [x] User feedback messages
- [x] Basic Monitoring:
  - [x] Request logging
  - [x] Token usage alerts
  - [x] Rate limiting enforcement
  - [x] User feedback messages
- [ ] Advanced Operations:
  - [x] **Performance metrics** (`/metrics` endpoint)
  - [ ] Automated database backups
  - [ ] Resource usage alerts or additional monitoring
  - [ ] Log rotation and retention
  - [ ] Automated deployment pipeline

### Progress Summary

- **Completed**: ~95%
- **Remaining**:
  - Phase 11: Additional tests and full documentation
  - Phase 12: Advanced monitoring & operational improvements (e.g., automated backups, resource usage alerts, log rotation)

## Questions to Consider
1. What should be the default summary interval (e.g., 6 hours, 12 hours)?
2. What should be the minimum number of messages before generating a summary?
3. Should we skip summary generation if there's too little activity?
4. How long should we retain message references?
5. How should we handle large gaps in conversation?
6. Should we add quick commands to adjust summary intervals?
7. How should we handle rate limiting for large groups?
8. What metrics should we track for optimization?

## Next Steps
1. ~~Begin with MVP Phase 1 implementation~~ âœ“
2. ~~Create test group for basic feature validation~~ âœ“
3. ~~Get early feedback on summary quality~~ âœ“
4. Evaluate performance and resource usage
5. Regular progress reviews and roadmap updates
6. Implement advanced summary formatting
7. Add support for multiple languages
8. Optimize token usage and costs

> Note: This roadmap is a living document and will be updated as development progresses and requirements evolve.

</document_content>
</document>
<document index="33">
<source>tsconfig.json</source>
<document_content>
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "types": ["bun-types"],
    "esModuleInterop": true,
    "strict": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "rootDir": "src",
    "outDir": "dist",
    "baseUrl": "src",
    "paths": {
      "@/*": ["*"]
    }
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}

</document_content>
</document>
<document index="34">
<source>.cursorrules</source>
<document_content>
<project_description>
You are working on Zenopsis - a Telegram bot project that monitors group chat messages, stores them in a database, and provides AI-powered conversation summaries using OpenAI's LLM.
</project_description>

<guidelines>
Project Guidelines:
1. All code must be written in TypeScript with proper type definitions
2. Use Bun.js as the runtime environment
3. Follow clean code principles and maintain consistent formatting
4. Write meaningful commit messages describing the changes
5. You must update the ROADMAP.md file with the latest changes and progress.
</guidelines>

<tech_stack>
Technology Stack:
- GramIO Framework for Telegram Bot API interactions
- Drizzle ORM for database operations
- Instructor.js for structured OpenAI API interactions
</tech_stack>

<architecture>
Project Structure:
/src
  /bot     - Telegram bot implementation using GramIO
  /db      - Database models, migrations, and Drizzle ORM setup
  /llm     - OpenAI integration and conversation summarization logic
  /types   - TypeScript type definitions and interfaces
</architecture>

<features>
Core Features:
1. Monitor and capture all messages in Telegram group chats
2. Store messages in a database using Drizzle ORM
3. Periodically summarize conversations using OpenAI's LLM
4. Post summaries back to the group chat automatically
</features>

<best_practices>
Best Practices:
1. Keep sensitive data (API keys, tokens) in environment variables
2. Write modular and reusable code
3. Handle errors gracefully with proper logging
4. Document complex logic and important functions
5. Use TypeScript's type system effectively to prevent runtime errors
</best_practices>
</document_content>
</document>
</documents>
